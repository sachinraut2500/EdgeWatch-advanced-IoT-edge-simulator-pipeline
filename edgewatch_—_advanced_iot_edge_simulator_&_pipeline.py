# -*- coding: utf-8 -*-
"""EdgeWatch — advanced IoT edge simulator & pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o3OR4VeCzokBLLmhDBl_dThg6i_3XQrR
"""

# edgewatch.py
"""
EdgeWatch - Advanced IoT edge simulator & pipeline
Single-file demo runnable in Google Colab.
Features:
 - Sensor simulator (temp, humidity, vibration, gps)
 - MQTT publisher (simulated edge device)
 - MQTT subscriber (cloud/edge collector) -> SQLite
 - Simple anomaly detection (Z-score + IsolationForest optional)
 - REST API (Flask) to query latest telemetry
 - Plotly offline dashboard generator (works in Colab)
 - OTA update simulation endpoint
Usage:
  python edgewatch.py --mode all
  python edgewatch.py --mode publisher
  python edgewatch.py --mode collector
  python edgewatch.py --mode dashboard
Config via environment variables or CLI args (see README).
"""
import os
import time
import json
import sqlite3
import random
import argparse
import threading
import asyncio
from datetime import datetime, timezone
from collections import deque, defaultdict

# External libs (install required)
try:
    import paho.mqtt.client as mqtt
    from flask import Flask, jsonify, request
    import plotly.graph_objs as go
    from plotly.offline import plot
except Exception as e:
    # Helpful message; actual installation instructions are in README.
    raise RuntimeError(
        "Missing dependencies. Run `pip install -r requirements.txt` (see README)."
    ) from e

# Optional ML
HAS_SKLEARN = False
try:
    from sklearn.ensemble import IsolationForest
    import numpy as np
    HAS_SKLEARN = True
except Exception:
    HAS_SKLEARN = False

# ---------- Configuration ----------
MQTT_BROKER = os.environ.get("EDGEWATCH_MQTT_BROKER", "test.mosquitto.org")
MQTT_PORT = int(os.environ.get("EDGEWATCH_MQTT_PORT", 1883))
MQTT_TOPIC_PREFIX = os.environ.get("EDGEWATCH_MQTT_TOPIC", "edgewatch")
DEVICE_ID = os.environ.get("EDGEWATCH_DEVICE_ID", "edge-sim-001")
SQLITE_DB = os.environ.get("EDGEWATCH_DB", "edgewatch.db")
PUBLISH_INTERVAL = float(os.environ.get("EDGEWATCH_PUBLISH_INTERVAL", 2.0))  # seconds
SIMULATED_SENSORS = ["temp", "humidity", "vibration", "gps"]
# ---------- End config ----------

# ---------- Utilities ----------
def now_iso():
    return datetime.now(timezone.utc).isoformat()

def random_gps(center=(37.7749, -122.4194), radius_km=0.5):
    # returns lat, lon within ~radius_km of center
    lat0, lon0 = center
    # approximate conversion
    km_per_deg = 110.574
    dlat = (random.random() - 0.5) * (radius_km / km_per_deg) * 2
    dlon = (random.random() - 0.5) * (radius_km / (km_per_deg * abs(math.cos(math.radians(lat0))))) * 2
    return lat0 + dlat, lon0 + dlon

import math

# ---------- Sensor Simulator ----------
class SensorSimulator:
    def __init__(self, device_id=DEVICE_ID):
        self.device_id = device_id
        self.seq = 0
        # baseline values for a "machine"
        self.base_temp = 36.5  # deg C
        self.base_hum = 40.0   # %
        self.base_vibe = 0.02  # g (vibration)
        self.gps_center = (37.7749, -122.4194)  # SF

    def read(self):
        self.seq += 1
        # simulate slow drift + occasional spikes/faults
        temp = self.base_temp + random.gauss(0, 0.5) + 0.01 * (self.seq % 100)
        humidity = self.base_hum + random.gauss(0, 1.2)
        # occasional high vibration (fault) with small prob
        if random.random() < 0.01:
            vibration = self.base_vibe + random.uniform(0.5, 2.0)
        else:
            vibration = self.base_vibe + abs(random.gauss(0, 0.01))
        # GPS jitter
        lat, lon = random_gps(self.gps_center, radius_km=0.05)
        payload = {
            "device_id": self.device_id,
            "seq": self.seq,
            "timestamp": now_iso(),
            "sensor": {
                "temp": round(temp, 3),
                "humidity": round(humidity, 2),
                "vibration": round(vibration, 4),
                "gps": {"lat": round(lat, 6), "lon": round(lon, 6)},
            }
        }
        return payload

# ---------- MQTT Publisher (simulated edge device) ----------
class MQTTPublisher(threading.Thread):
    def __init__(self, simulator: SensorSimulator, topic_prefix=MQTT_TOPIC_PREFIX, interval=PUBLISH_INTERVAL, broker=MQTT_BROKER, port=MQTT_PORT):
        super().__init__(daemon=True)
        self.sim = simulator
        self.interval = interval
        self.topic_prefix = topic_prefix
        self.client = mqtt.Client(client_id=f"pub-{simulator.device_id}-{random.randint(0,9999)}")
        self.broker = broker
        self.port = port
        self.running = threading.Event()
        self.running.set()

    def run(self):
        self.client.connect(self.broker, self.port, keepalive=60)
        self.client.loop_start()
        topic = f"{self.topic_prefix}/{self.sim.device_id}/telemetry"
        print(f"[Publisher] publishing to mqtt://{self.broker}:{self.port}/{topic}")
        try:
            while self.running.is_set():
                payload = self.sim.read()
                payload_json = json.dumps(payload)
                self.client.publish(topic, payload_json, qos=0)
                print(f"[Publisher] published seq={payload['seq']}")
                time.sleep(self.interval)
        finally:
            self.client.loop_stop()
            self.client.disconnect()

    def stop(self):
        self.running.clear()

# ---------- SQLite Storage & Collector ----------
class TelemetryStore:
    def __init__(self, db_path=SQLITE_DB):
        self.db_path = db_path
        self._ensure_tables()

    def _conn(self):
        return sqlite3.connect(self.db_path, check_same_thread=False)

    def _ensure_tables(self):
        conn = self._conn()
        cur = conn.cursor()
        cur.execute("""
        CREATE TABLE IF NOT EXISTS telemetry (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            device_id TEXT,
            seq INTEGER,
            timestamp TEXT,
            temp REAL,
            humidity REAL,
            vibration REAL,
            gps_lat REAL,
            gps_lon REAL,
            raw TEXT
        )
        """)
        conn.commit()
        conn.close()

    def insert(self, payload):
        conn = self._conn()
        cur = conn.cursor()
        s = payload
        cur.execute("""
        INSERT INTO telemetry (device_id, seq, timestamp, temp, humidity, vibration, gps_lat, gps_lon, raw)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, (
            s["device_id"],
            s["seq"],
            s["timestamp"],
            s["sensor"]["temp"],
            s["sensor"]["humidity"],
            s["sensor"]["vibration"],
            s["sensor"]["gps"]["lat"],
            s["sensor"]["gps"]["lon"],
            json.dumps(s)
        ))
        conn.commit()
        conn.close()

    def recent(self, device_id=None, limit=200):
        conn = self._conn()
        cur = conn.cursor()
        if device_id:
            cur.execute("SELECT timestamp, temp, humidity, vibration, gps_lat, gps_lon FROM telemetry WHERE device_id=? ORDER BY id DESC LIMIT ?", (device_id, limit))
        else:
            cur.execute("SELECT timestamp, temp, humidity, vibration, gps_lat, gps_lon FROM telemetry ORDER BY id DESC LIMIT ?", (limit,))
        rows = cur.fetchall()
        conn.close()
        # return as list of dicts
        result = []
        for r in rows:
            result.append({
                "timestamp": r[0],
                "temp": r[1],
                "humidity": r[2],
                "vibration": r[3],
                "gps_lat": r[4],
                "gps_lon": r[5]
            })
        return result

# ---------- MQTT Subscriber (Collector) ----------
class MQTTCollector:
    def __init__(self, store: TelemetryStore, topic_prefix=MQTT_TOPIC_PREFIX, broker=MQTT_BROKER, port=MQTT_PORT):
        self.store = store
        self.client = mqtt.Client(client_id=f"collector-{random.randint(0,9999)}")
        self.broker = broker
        self.port = port
        self.topic = f"{topic_prefix}/+/telemetry"
        # simple in-memory queue for anomaly analysis
        self.window = deque(maxlen=500)
        self.lock = threading.Lock()
        self.running = False

        # anomaly state
        self.anomalies = []

        # optional ML model
        self.ml_model = None
        if HAS_SKLEARN:
            self.ml_model = IsolationForest(contamination=0.01, random_state=42)

        self.client.on_connect = self._on_connect
        self.client.on_message = self._on_message

    def _on_connect(self, client, userdata, flags, rc):
        print(f"[Collector] connected (rc={rc}). subscribing to {self.topic}")
        client.subscribe(self.topic)

    def _on_message(self, client, userdata, msg):
        try:
            payload = json.loads(msg.payload.decode("utf-8"))
            # store raw
            self.store.insert(payload)
            # add to window for anomaly detection
            t = payload["timestamp"]
            temp = payload["sensor"]["temp"]
            vib = payload["sensor"]["vibration"]
            with self.lock:
                self.window.append((t, temp, vib))
                # run quick z-score anomaly detection
                if len(self.window) >= 10:
                    temps = [x[1] for x in self.window]
                    vibvals = [x[2] for x in self.window]
                    # compute z-score for last point
                    last_temp = temps[-1]
                    mean_t = sum(temps[:-1]) / max(1, len(temps)-1)
                    std_t = (sum((x-mean_t)**2 for x in temps[:-1]) / max(1, len(temps)-2)) ** 0.5 if len(temps) > 2 else 0.0001
                    zt = abs((last_temp - mean_t) / (std_t if std_t>0 else 1e-6))
                    last_vib = vibvals[-1]
                    mean_v = sum(vibvals[:-1]) / max(1, len(vibvals)-1)
                    std_v = (sum((x-mean_v)**2 for x in vibvals[:-1]) / max(1, len(vibvals)-2)) ** 0.5 if len(vibvals) > 2 else 0.0001
                    zv = abs((last_vib - mean_v) / (std_v if std_v>0 else 1e-6))
                    if zt > 3.5 or zv > 3.5 or last_vib > 0.2:
                        anomaly = {"time": t, "temp": last_temp, "vibration": last_vib, "zt": zt, "zv": zv}
                        print(f"[Collector] Anomaly detected: {anomaly}")
                        self.anomalies.append(anomaly)
        except Exception as ex:
            print("[Collector] error parsing message:", ex)

    def start(self):
        self.running = True
        self.client.connect(self.broker, self.port, keepalive=60)
        self.client.loop_start()
        print("[Collector] started")

    def stop(self):
        self.running = False
        self.client.loop_stop()
        self.client.disconnect()
        print("[Collector] stopped")

# ---------- REST API (Flask) ----------
def create_api(store: TelemetryStore, collector: MQTTCollector=None):
    app = Flask("edgewatch_api")

    @app.route("/health")
    def health():
        return jsonify({"status": "ok", "time": now_iso(), "db": os.path.abspath(store.db_path)})

    @app.route("/telemetry/recent")
    def recent():
        device = request.args.get("device")
        limit = int(request.args.get("limit", 200))
        return jsonify(store.recent(device, limit))

    @app.route("/anomalies")
    def anomalies():
        if collector:
            return jsonify(collector.anomalies)
        return jsonify([])

    @app.route("/ota", methods=["POST"])
    def ota():
        """
        OTA update simulation:
        POST JSON { "device_id": "...", "action": "update", "version": "v1.2.3" }
        """
        body = request.get_json(force=True)
        dev = body.get("device_id")
        action = body.get("action")
        version = body.get("version")
        # For demo, we simply record request and return a "signed" manifest
        manifest = {
            "device_id": dev,
            "action": action,
            "version": version,
            "url": f"https://example.com/firmware/{dev}/{version}.bin",
            "checksum": "deadbeefcafebabe",
            "timestamp": now_iso()
        }
        return jsonify({"result": "ok", "manifest": manifest})

    return app

# ---------- Dashboard (Plotly) ----------
def generate_plotly_dashboard(store: TelemetryStore, device_id=None, limit=200, output_html="dashboard.html"):
    rows = store.recent(device_id=device_id, limit=limit)[::-1]  # oldest -> newest
    if not rows:
        print("[Dashboard] No data to plot.")
        return None
    times = [r["timestamp"] for r in rows]
    temps = [r["temp"] for r in rows]
    hums = [r["humidity"] for r in rows]
    vibs = [r["vibration"] for r in rows]

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=times, y=temps, mode="lines+markers", name="Temp (°C)"))
    fig.add_trace(go.Scatter(x=times, y=hums, mode="lines+markers", name="Humidity (%)", yaxis="y2"))
    fig.add_trace(go.Scatter(x=times, y=vibs, mode="lines+markers", name="Vibration (g)", yaxis="y3"))
    # Layout with multiple y axes
    fig.update_layout(
        title=f"EdgeWatch Telemetry ({device_id or 'all devices'})",
        xaxis=dict(title="Time"),
        yaxis=dict(title="Temperature (°C)"),
        yaxis2=dict(title="Humidity (%)", overlaying="y", side="right"),
        yaxis3=dict(title="Vibration (g)", anchor="free", overlaying="y", side="left", position=0.05),
        legend=dict(orientation="h")
    )
    # Save offline HTML
    plot(fig, filename=output_html, auto_open=False)
    print(f"[Dashboard] saved to {output_html}")
    return output_html

# ---------- CLI / Runner ----------
def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--mode", choices=["publisher", "collector", "api", "dashboard", "all"], default="all",
                        help="Which component to run")
    parser.add_argument("--broker", default=MQTT_BROKER)
    parser.add_argument("--db", default=SQLITE_DB)
    parser.add_argument("--device", default=DEVICE_ID)
    parser.add_argument("--interval", type=float, default=PUBLISH_INTERVAL)
    parser.add_argument("--publish-for", type=int, default=60, help="publisher: seconds to publish (0 = forever)")
    parser.add_argument("--host", default="0.0.0.0")
    parser.add_argument("--port", type=int, default=5000)
    args = parser.parse_args()

    # override config
    global MQTT_BROKER, SQLITE_DB, DEVICE_ID, PUBLISH_INTERVAL
    MQTT_BROKER = args.broker
    SQLITE_DB = args.db
    DEVICE_ID = args.device
    PUBLISH_INTERVAL = args.interval

    store = TelemetryStore(SQLITE_DB)
    simulator = SensorSimulator(device_id=DEVICE_ID)

    publisher = MQTTPublisher(simulator, broker=MQTT_BROKER, interval=PUBLISH_INTERVAL)
    collector = MQTTCollector(store, broker=MQTT_BROKER)

    if args.mode in ("collector", "api", "dashboard", "all"):
        collector.start()

    if args.mode in ("publisher", "all"):
        publisher.start()

    app = create_api(store, collector)

    try:
        if args.mode == "publisher":
            # run for N seconds (or forever)
            if args.publish_for > 0:
                time.sleep(args.publish_for)
                publisher.stop()
            else:
                while True:
                    time.sleep(1)

        elif args.mode == "collector":
            # collector just runs (we block)
            while True:
                time.sleep(1)

        elif args.mode == "api":
            # run Flask API
            print(f"[API] starting on http://{args.host}:{args.port}")
            app.run(host=args.host, port=args.port, debug=False, use_reloader=False)

        elif args.mode == "dashboard":
            out = generate_plotly_dashboard(store, device_id=args.device)
            print("Dashboard saved at:", out)

        elif args.mode == "all":
            # Run API + background publisher + collector
            # Start Flask in a separate thread to allow non-blocking (useful in environment like Colab)
            def flask_thread():
                print(f"[API] starting on http://{args.host}:{args.port}")
                app.run(host=args.host, port=args.port, debug=False, use_reloader=False)

            t = threading.Thread(target=flask_thread, daemon=True)
            t.start()
            print("[EdgeWatch] Running publisher + collector + API. Press Ctrl+C to stop.")
            while True:
                time.sleep(1)
    except KeyboardInterrupt:
        print("Shutting down...")
    finally:
        publisher.stop()
        collector.stop()

if __name__ == "__main__":
    main()